package edu.cmu.sv.kelinci.instrumentor;

import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.HashSet;
import java.util.Set;

import org.apache.commons.io.IOUtils;
import org.kohsuke.args4j.CmdLineException;
import org.kohsuke.args4j.CmdLineParser;
import org.objectweb.asm.ClassReader;
import org.objectweb.asm.ClassWriter;

import de.hub.se.cfg.CFGAnalysis;
import de.hub.se.cfg.CFGBuilder;
import de.hub.se.cfg.CFGUtility;
import edu.cmu.sv.kelinci.instrumentor.Options.InstrumentationMode;

/**
 * @author rodykers
 *
 *         Instrumentation component of Kelinci. Adds AFL style instrumentation to a JAVA program, plus the Kelinci
 *         'javaside' component.
 * 
 *         added CFG construction: Yannic Noller <nolleryc@gmail.com> - YN
 */
public class Instrumentor {

    public static ClassLoader classloader;

    public static CFGAnalysis cfga;

    public static void main(String[] args) {

        // get class loader
        classloader = Thread.currentThread().getContextClassLoader();

        // parse command line arguments
        Options options = Options.v();
        CmdLineParser parser = new CmdLineParser(options);
        try {
            parser.parseArgument(args);
        } catch (CmdLineException e) {
            parser.printUsage(System.err);
            return;
        }

        // load all classes to instrument (instrument library classes?)
        Set<String> inputClasses = Options.v().getInput();
        Set<String> inputClassesFullPath = Options.v().getInputFullPath();
        Set<String> skipped = new HashSet<>();
        
        Set<String> classesToSkip = Options.v().getAllClassesToSkip();

        /* YN: for regression mode we need CFG information */
        if (Options.v().getInstrumentationMode().equals(InstrumentationMode.REGRESSION)
                || Options.v().getInstrumentationMode().equals(InstrumentationMode.REGRESSION_NO_DEC)) {
            cfga = CFGBuilder.genCFGForClasses(inputClassesFullPath, classesToSkip, null);

            /* Calculate distances if defined. Could be also done when starting the Kelinci server. */
            String targetDistanceCalculation = Options.v().getRawDistanceTargets();
            if (targetDistanceCalculation != null && !targetDistanceCalculation.isEmpty()) {
                cfga.calculateDistancesToTargets(Options.v().getDistanceTargets());
            }

            /* Export CFG file if asked for. */
            String cfgExportDir = Options.v().getCFGExportDir();
            if (cfgExportDir != null && !cfgExportDir.isEmpty()) {
                CFGUtility.serialize(cfga, cfgExportDir);
            }
            
        }

       
        for (String cls : inputClasses) {

            // YN: skip classes as configured
            if (classesToSkip.contains(cls)) {
                System.out.println("Skip instrumenting class: " + cls);
                /* Copy them to output folder. */
                loadAndWriteResource(cls);
                continue;
            }

            System.out.println("Instrumenting class: " + cls);
            InputStream bytecode = classloader.getResourceAsStream(cls);

            ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_FRAMES);
            ClassTransformer ct = new ClassTransformer(cw);
            ClassReader cr;
            try {
                cr = new ClassReader(bytecode);
            } catch (IOException | NullPointerException e) {
                System.err.println("Error loading class: " + cls);
                e.printStackTrace();
                return;
            }

            try {
                cr.accept(ct, 0);
                byte[] bytes = cw.toByteArray();
                writeClass(cls, bytes);
            } catch (RuntimeException rte) {
                if (rte.getMessage().contains("JSR/RET")) {
                    /**
                     * This is an exception related to a particular construct in the bytecode that is not supported by
                     * ASM. It is deprecated and should not be present in bytecode generated by a recent compiler.
                     * However, the JDK contains it and it may occur elsewhere. This catch simply skips the class and
                     * warns the user.
                     */
                    System.out
                            .println("\n[WARNING] RuntimeException thrown during instrumentation: " + rte.getMessage());
                    System.out.println("Skipping instrumentation of class " + cls + "\n");
                    // include original, uninstrumented class in output
                    loadAndWriteResource(cls);
                    skipped.add(cls);
                } else {
                    throw rte;
                }
            }

        }

        // add Kelinci classes
        String[] resources = { "edu/cmu/sv/kelinci/Kelinci.class", "edu/cmu/sv/kelinci/Kelinci$1.class",
                "edu/cmu/sv/kelinci/Kelinci$2.class", "edu/cmu/sv/kelinci/Kelinci$3.class",
                "edu/cmu/sv/kelinci/Kelinci$ApplicationCall.class", "edu/cmu/sv/kelinci/Kelinci$FuzzRequest.class",
                "edu/cmu/sv/kelinci/Kelinci$NullOutputStream.class", "edu/cmu/sv/kelinci/Mem.class",
                "edu/cmu/sv/kelinci/regression/CFGSummary.class", "edu/cmu/sv/kelinci/regression/DecisionHistory.class",
                "edu/cmu/sv/kelinci/regression/DecisionHistory$DecisionPoint.class",
                "edu/cmu/sv/kelinci/regression/DecisionHistoryDifference.class",
                "edu/cmu/sv/kelinci/regression/OutputSummary.class", "edu/cmu/sv/kelinci/regression/CostSummary.class",
                "de/hub/se/cfg/CFGTarget.class"
                // "edu/cmu/sv/kelinci/regression/cfg/CFG.class",
                // "edu/cmu/sv/kelinci/regression/cfg/CFGAnalysis.class",
                // "edu/cmu/sv/kelinci/regression/cfg/CFGEdge.class",
                // "edu/cmu/sv/kelinci/regression/cfg/CFGNode.class",
                // "edu/cmu/sv/kelinci/regression/cfg/CFGTarget.class",
                // "edu/cmu/sv/kelinci/regression/cfg/CFGUtility.class"
                // "de/hub/se/cfg/CFGBuilder",
        };
        for (String resource : resources) {
            loadAndWriteResource(resource);
        }

        if (skipped.size() > 0) {
            System.out.println("\nWARNING!!! Instrumentation of some classes has been skipped.");
            System.out.println("This is due to the JSR/RET bytecode construct that is not supported by ASM.");
            System.out
                    .println("It is deprecated and should not be present in bytecode generated by a recent compiler.");
            System.out.println("If this is your code, try using a different compiler.");
            System.out.println(
                    "If this is a library, there might be not too much harm in skipping instrumentation of these classes.");
            System.out.println("Classes that were skipped:");
            for (String cls : skipped)
                System.out.println(cls);
        }
    }

    private static void writeClass(String cls, byte[] bytes) {
        if (Options.v().outputJar()) {
            JarFileIO.v().addFileToJar(cls, bytes);
        } else {
            String path = Options.v().getOutput().endsWith("/") ? Options.v().getOutput() + cls
                    : Options.v().getOutput() + "/" + cls;
            Path out = Paths.get(path);
            try {
                Files.createDirectories(out.getParent());
                Files.write(out, bytes);
                System.out.println("File written: " + path);
            } catch (IOException e) {
                System.err.println("Error writing to file: " + path);
                e.printStackTrace();
            }
        }
    }

    private static void loadAndWriteResource(String resource) {
        InputStream is = classloader.getResourceAsStream(resource);
        if (is == null) {
            System.err.println("Error loading Kelinci classes for addition to output: " + resource);
            return;
        }
        byte[] rbytes;
        try {
            rbytes = IOUtils.toByteArray(is);
        } catch (IOException e) {
            System.err.println("Error loading Kelinci classes for addition to output");
            e.printStackTrace();
            return;
        }
        writeClass(resource, rbytes);
    }
}
